{% extends "base.html" %}

{% block title %}LIVE: {{ guide.title }} - {{ podcast.name }} - {{ APP_NAME }}{% endblock %}

{% macro render_item(item, idx) %}
<div class="py-1.5 px-3 flex items-center gap-2 hover:bg-surface-50 transition-all cursor-pointer"
     :class="focusedItemId === {{ item.id }} ? 'ring-2 ring-primary-500 ring-inset bg-primary-50' : ''"
     @click="focusedItemId = {{ item.id }}"
     data-item-id="{{ item.id }}">
    <!-- Discussed checkbox -->
    <input type="checkbox"
        :checked="discussed[{{ item.id }}]"
        @change="toggleDiscussed({{ item.id }}, $event.target.checked)"
        class="w-4 h-4 rounded border-gray-300 text-primary-600 focus:ring-primary-500 flex-shrink-0">

    <!-- Topic Number -->
    <span class="text-gray-400 text-xs font-medium flex-shrink-0">{{ idx }}.</span>

    <!-- Item content -->
    <div class="flex-1 min-w-0">
        <div class="font-medium text-gray-900 text-sm" :class="discussed[{{ item.id }}] ? 'line-through text-gray-400' : ''">
            {{ item.title }}
        </div>
        {% for link in item.all_links %}
            <a href="{{ link if link.startswith('http') else 'https://' + link }}" target="_blank" class="text-xs text-primary-600 hover:underline truncate block">{{ link }}</a>
        {% endfor %}
        {% if item.notes %}
            <div class="text-xs text-gray-500">{{ item.notes }}</div>
        {% endif %}
    </div>

    <!-- Timestamp display/button -->
    <div class="flex-shrink-0">
        <template x-if="timestamps[{{ item.id }}] !== null && timestamps[{{ item.id }}] !== undefined">
            <span class="inline-flex items-center px-2 py-1 rounded bg-emerald-100 text-emerald-700 font-mono font-medium text-xs"
                x-text="formatTime(timestamps[{{ item.id }}])">
            </span>
        </template>
        <template x-if="timestamps[{{ item.id }}] === null || timestamps[{{ item.id }}] === undefined">
            <button @click="markTimestamp({{ item.id }})"
                :disabled="!timerRunning"
                :class="timerRunning ? 'bg-primary-600 hover:bg-primary-700 text-white' : 'bg-gray-200 text-gray-400 cursor-not-allowed'"
                class="px-3 py-1 rounded font-medium text-xs transition-colors">
                MARK
            </button>
        </template>
    </div>
</div>
{% endmacro %}

{% block content %}
<div class="space-y-4" x-data="episodeGuideLive({{ podcast.id }}, {{ guide.id }}, '{{ guide.status }}', '{{ guide.recording_started_at.isoformat() if guide.recording_started_at else '' }}')">
    <!-- Compact Timer Overlay -->
    <div class="fixed top-20 right-4 z-40 bg-white rounded-lg shadow-lg border border-surface-200 px-3 py-2 flex items-center gap-3">
        <!-- Recording indicator -->
        <template x-if="timerRunning">
            <span class="w-2.5 h-2.5 bg-red-600 rounded-full animate-pulse flex-shrink-0"></span>
        </template>

        <!-- Timer Display -->
        <div class="font-mono font-bold text-lg" :class="timerRunning ? 'text-red-600' : 'text-gray-500'">
            <span x-text="formatTime(elapsedSeconds)">00:00:00</span>
        </div>

        <!-- Timer Controls -->
        <template x-if="!timerRunning && elapsedSeconds === 0">
            <button @click="startRecording()" class="inline-flex items-center gap-1.5 bg-emerald-600 text-white px-3 py-1.5 rounded hover:bg-emerald-700 font-medium text-sm">
                <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"/></svg>
                Start
            </button>
        </template>

        <template x-if="timerRunning">
            <button @click="stopRecording()" class="inline-flex items-center gap-1.5 bg-red-600 text-white px-3 py-1.5 rounded hover:bg-red-700 font-medium text-sm">
                <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 001 1h4a1 1 0 001-1V8a1 1 0 00-1-1H8z" clip-rule="evenodd"/></svg>
                Stop
            </button>
        </template>

        <template x-if="!timerRunning && elapsedSeconds > 0">
            <div class="flex gap-2">
                <button @click="resumeTimer()" class="inline-flex items-center gap-1 bg-amber-600 text-white px-2.5 py-1.5 rounded hover:bg-amber-700 font-medium text-sm">
                    <svg class="w-3.5 h-3.5" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"/></svg>
                    Resume
                </button>
                <a href="{{ url_for('podcasts.view_episode', podcast_id=podcast.id, episode_id=guide.id) }}" class="inline-flex items-center bg-gray-600 text-white px-2.5 py-1.5 rounded hover:bg-gray-700 font-medium text-sm">
                    View
                </a>
            </div>
        </template>

        <!-- Divider -->
        <div class="w-px h-6 bg-gray-200"></div>

        <!-- Settings toggles -->
        <div class="flex items-center gap-2">
            <!-- Keyboard toggle -->
            <button @click="toggleKeyboard()"
                    :class="keyboardEnabled ? 'text-primary-600 bg-primary-50' : 'text-gray-400 hover:text-gray-600'"
                    class="p-1.5 rounded transition-colors"
                    :title="keyboardEnabled ? 'Keyboard shortcuts ON' : 'Keyboard shortcuts OFF'">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19V5M5 12l7-7 7 7"/>
                </svg>
            </button>
            <!-- Sound toggle -->
            <button @click="toggleSound()"
                    :class="soundEnabled ? 'text-primary-600 bg-primary-50' : 'text-gray-400 hover:text-gray-600'"
                    class="p-1.5 rounded transition-colors"
                    :title="soundEnabled ? 'Sound ON' : 'Sound OFF'">
                <svg x-show="soundEnabled" class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072M18.364 5.636a9 9 0 010 12.728M6 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h2l4-4v14l-4-4z"/>
                </svg>
                <svg x-show="!soundEnabled" class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z"/>
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2"/>
                </svg>
            </button>
            <!-- Help tooltip -->
            <div class="relative" x-data="{ showHelp: false }">
                <button @mouseenter="showHelp = true" @mouseleave="showHelp = false"
                        class="p-1.5 text-gray-400 hover:text-gray-600 rounded transition-colors">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                    </svg>
                </button>
                <div x-show="showHelp" x-cloak
                     class="absolute right-0 top-full mt-2 w-48 bg-gray-900 text-white text-xs rounded-lg shadow-lg p-3 z-50">
                    <div class="font-semibold mb-2">Keyboard Shortcuts</div>
                    <div class="space-y-1">
                        <div class="flex justify-between"><span>Space</span><span class="text-gray-400">Mark timestamp</span></div>
                        <div class="flex justify-between"><span>↑ / ↓</span><span class="text-gray-400">Navigate</span></div>
                        <div class="flex justify-between"><span>D</span><span class="text-gray-400">Toggle discussed</span></div>
                        <div class="flex justify-between"><span>M</span><span class="text-gray-400">Mark + next</span></div>
                        <div class="flex justify-between"><span>S</span><span class="text-gray-400">Start/Stop</span></div>
                        <div class="flex justify-between"><span>Esc</span><span class="text-gray-400">Clear focus</span></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Page Header -->
    <div class="flex items-center justify-between">
        <div class="flex items-center gap-2">
            <a href="{{ url_for('podcasts.edit_episode', podcast_id=podcast.id, episode_id=guide.id) }}" class="text-gray-400 hover:text-gray-600">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"/></svg>
            </a>
            {% if guide.episode_number %}
                <span class="text-gray-400 text-sm">#{{ guide.episode_number }}</span>
            {% endif %}
            <h1 class="text-lg font-bold text-gray-900">{{ guide.title }}</h1>
        </div>
        <span class="text-xs text-gray-500" x-show="Object.values(timestamps).filter(t => t !== null).length > 0">
            <span x-text="Object.values(timestamps).filter(t => t !== null).length"></span> timestamps
        </span>
    </div>

    <!-- Sections -->
    <div class="space-y-4">
        <!-- INTRO Section -->
        <div>
            <div class="bg-gradient-to-r from-purple-600 to-purple-700 rounded-t-xl px-4 py-2">
                <h2 class="text-base font-bold text-white uppercase tracking-wide">INTRO</h2>
            </div>
            <div class="bg-white rounded-b-xl border border-t-0 border-surface-200 overflow-hidden">
                {% set intro_content = guide.get_intro_content() %}
                {% if intro_content or guide.previous_poll or guide.new_poll %}
                <div class="bg-blue-50 border-b border-blue-100 p-3">
                    <ul class="text-xs text-blue-800 space-y-0.5">
                        {% for line in intro_content %}
                        <li>{{ line }}</li>
                        {% endfor %}
                        {% if guide.previous_poll or guide.new_poll %}
                        <li class="font-semibold">
                            Previous Poll: {{ guide.previous_poll or '[Not set]' }}
                            {% if guide.previous_poll_link %}
                            <a href="{{ guide.previous_poll_link if guide.previous_poll_link.startswith('http') else 'https://' + guide.previous_poll_link }}" target="_blank" class="text-blue-600 hover:underline ml-1">[Link]</a>
                            {% endif %}
                        </li>
                        <li class="font-semibold">
                            New Poll: {{ guide.new_poll or '[Not set]' }}
                            {% if guide.new_poll_link %}
                            <a href="{{ guide.new_poll_link if guide.new_poll_link.startswith('http') else 'https://' + guide.new_poll_link }}" target="_blank" class="text-blue-600 hover:underline ml-1">[Link]</a>
                            {% endif %}
                        </li>
                        {% endif %}
                    </ul>
                </div>
                {% endif %}
                {% set intro_items = sections.get('introduction', {}).get('items', []) %}
                {% if intro_items %}
                <div class="divide-y divide-surface-200">
                    {% for item in intro_items %}
                        {{ render_item(item, loop.index) }}
                    {% endfor %}
                </div>
                {% endif %}
            </div>
        </div>

        <!-- NEWS Section -->
        <div>
            <div class="bg-gradient-to-r from-red-600 to-red-700 rounded-t-xl px-4 py-2">
                <h2 class="text-base font-bold text-white uppercase tracking-wide">NEWS</h2>
            </div>
            <div class="bg-white rounded-b-xl border border-t-0 border-surface-200 overflow-hidden">
                {% for sub_key, sub_name in [('news_mice', 'Mice'), ('news_other', 'Other'), ('news_pads', 'Pads'), ('news_keyboards', 'Keyboards')] %}
                    {% set sub_items = sections.get(sub_key, {}).get('items', []) %}
                    {% if sub_items %}
                    <div class="py-1.5 px-3 bg-surface-50 border-b border-surface-200">
                        <span class="text-xs font-semibold text-gray-700">{{ sub_name }}</span>
                        <span class="text-xs text-gray-500 ml-1">({{ sub_items|length }})</span>
                    </div>
                    <div class="divide-y divide-surface-200">
                        {% for item in sub_items %}
                            {{ render_item(item, loop.index) }}
                        {% endfor %}
                    </div>
                    {% endif %}
                {% endfor %}
            </div>
        </div>

        <!-- COMMUNITY RECAP Section -->
        <div>
            <div class="bg-gradient-to-r from-emerald-600 to-emerald-700 rounded-t-xl px-4 py-2">
                <h2 class="text-base font-bold text-white uppercase tracking-wide">COMMUNITY RECAP</h2>
            </div>
            <div class="bg-white rounded-b-xl border border-t-0 border-surface-200 overflow-hidden">
                {% set cr_items = sections.get('community_recap', {}).get('items', []) %}
                {% if cr_items %}
                <div class="divide-y divide-surface-200">
                    {% for item in cr_items %}
                        {{ render_item(item, loop.index) }}
                    {% endfor %}
                </div>
                {% else %}
                <div class="p-4 text-center text-gray-400 text-xs">No topics</div>
                {% endif %}
            </div>
        </div>

        <!-- PERSONAL RAMBLINGS Section -->
        <div>
            <div class="bg-gradient-to-r from-amber-600 to-amber-700 rounded-t-xl px-4 py-2">
                <h2 class="text-base font-bold text-white uppercase tracking-wide">PERSONAL RAMBLINGS</h2>
            </div>
            <div class="bg-white rounded-b-xl border border-t-0 border-surface-200 overflow-hidden">
                {% set pr_items = sections.get('personal_ramblings', {}).get('items', []) %}
                {% if pr_items %}
                <div class="divide-y divide-surface-200">
                    {% for item in pr_items %}
                        {{ render_item(item, loop.index) }}
                    {% endfor %}
                </div>
                {% else %}
                <div class="p-4 text-center text-gray-400 text-xs">No topics</div>
                {% endif %}
            </div>
        </div>

        <!-- OUTRO Section -->
        <div>
            <div class="bg-gradient-to-r from-gray-600 to-gray-700 rounded-t-xl px-4 py-2">
                <h2 class="text-base font-bold text-white uppercase tracking-wide">OUTRO</h2>
            </div>
            <div class="bg-white rounded-b-xl border border-t-0 border-surface-200 overflow-hidden">
                {% set outro_content = guide.get_outro_content() %}
                {% if outro_content %}
                <div class="bg-blue-50 border-b border-blue-100 p-3">
                    <ul class="text-xs text-blue-800 space-y-0.5">
                        {% for line in outro_content %}
                        <li>{{ line }}</li>
                        {% endfor %}
                    </ul>
                </div>
                {% endif %}
                {% set outro_items = sections.get('outro', {}).get('items', []) %}
                {% if outro_items %}
                <div class="divide-y divide-surface-200">
                    {% for item in outro_items %}
                        {{ render_item(item, loop.index) }}
                    {% endfor %}
                </div>
                {% endif %}
            </div>
        </div>

        <!-- Custom Sections -->
        {% if guide.custom_sections %}
            {% for custom_section in guide.custom_sections %}
            <div>
                <div class="bg-gradient-to-r from-indigo-600 to-indigo-700 rounded-t-xl px-4 py-2">
                    <h2 class="text-base font-bold text-white uppercase tracking-wide">{{ custom_section.name }}</h2>
                </div>
                <div class="bg-white rounded-b-xl border border-t-0 border-surface-200 overflow-hidden">
                    {% set custom_items = sections.get(custom_section.key, {}).get('items', []) %}
                    {% if custom_items %}
                    <div class="divide-y divide-surface-200">
                        {% for item in custom_items %}
                            {{ render_item(item, loop.index) }}
                        {% endfor %}
                    </div>
                    {% else %}
                    <div class="p-4 text-center text-gray-400 text-xs">No topics</div>
                    {% endif %}
                </div>
            </div>
            {% endfor %}
        {% endif %}
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
function episodeGuideLive(podcastId, guideId, initialStatus, startedAtISO) {
    return {
        podcastId: podcastId,
        guideId: guideId,
        timerRunning: initialStatus === 'recording',
        elapsedSeconds: 0,
        timerInterval: null,
        startTime: startedAtISO ? new Date(startedAtISO) : null,

        // Keyboard shortcuts
        focusedItemId: null,
        keyboardEnabled: false,
        soundEnabled: false,
        allItemIds: [
            {% for section_key in ['introduction', 'news_mice', 'news_other', 'news_pads', 'news_keyboards', 'community_recap', 'personal_ramblings', 'outro'] %}
                {% for item in sections.get(section_key, {}).get('items', []) %}
                    {{ item.id }},
                {% endfor %}
            {% endfor %}
            {% if guide.custom_sections %}
                {% for custom_section in guide.custom_sections %}
                    {% for item in sections.get(custom_section.key, {}).get('items', []) %}
                        {{ item.id }},
                    {% endfor %}
                {% endfor %}
            {% endif %}
        ],

        // Item state
        timestamps: {
            {% for section_key in sections %}
                {% for item in sections[section_key].get('items', []) %}
                    {{ item.id }}: {{ item.timestamp_seconds if item.timestamp_seconds is not none else 'null' }},
                {% endfor %}
            {% endfor %}
        },
        discussed: {
            {% for section_key in sections %}
                {% for item in sections[section_key].get('items', []) %}
                    {{ item.id }}: {{ 'true' if item.discussed else 'false' }},
                {% endfor %}
            {% endfor %}
        },

        init() {
            // If status is draft, clear any stale localStorage and start fresh
            if ('{{ guide.status }}' === 'draft') {
                localStorage.removeItem(`guide_${this.guideId}_state`);
                this.startTime = null;
                this.timerRunning = false;
                this.elapsedSeconds = 0;
            }

            // Resume timer if already recording (use client-side tracking)
            if (this.timerRunning && this.startTime) {
                this.elapsedSeconds = Math.max(0, Math.floor((Date.now() - this.startTime.getTime()) / 1000));
                this.startTimerInterval();
            }

            // Try to restore from localStorage (only if not already set from server)
            const saved = localStorage.getItem(`guide_${this.guideId}_state`);
            if (saved && !this.startTime) {
                const state = JSON.parse(saved);
                if (state.startTime) {
                    this.startTime = new Date(state.startTime);
                    this.elapsedSeconds = Math.max(0, Math.floor((Date.now() - this.startTime.getTime()) / 1000));
                    if (state.timerRunning) {
                        this.timerRunning = true;
                        this.startTimerInterval();
                    }
                }
            }

            // Load keyboard/sound preferences from localStorage
            const prefs = localStorage.getItem(`guide_live_prefs`);
            if (prefs) {
                const p = JSON.parse(prefs);
                this.keyboardEnabled = p.keyboardEnabled ?? false;
                this.soundEnabled = p.soundEnabled ?? false;
            }

            // Set up keyboard shortcuts
            this.setupKeyboardShortcuts();

            // Auto-focus first undiscussed item if keyboard enabled
            if (this.keyboardEnabled) {
                this.focusFirstUndiscussed();
            }
        },

        toggleKeyboard() {
            this.keyboardEnabled = !this.keyboardEnabled;
            this.savePrefs();
            if (this.keyboardEnabled && !this.focusedItemId) {
                this.focusFirstUndiscussed();
            } else if (!this.keyboardEnabled) {
                this.focusedItemId = null;
            }
        },

        toggleSound() {
            this.soundEnabled = !this.soundEnabled;
            this.savePrefs();
        },

        savePrefs() {
            localStorage.setItem(`guide_live_prefs`, JSON.stringify({
                keyboardEnabled: this.keyboardEnabled,
                soundEnabled: this.soundEnabled
            }));
        },

        playSound(type) {
            if (!this.soundEnabled) return;
            // Simple beep using Web Audio API
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain);
            gain.connect(ctx.destination);
            gain.gain.value = 0.1;
            if (type === 'mark') {
                osc.frequency.value = 880; // High beep for mark
            } else {
                osc.frequency.value = 440; // Lower beep for navigation
            }
            osc.start();
            osc.stop(ctx.currentTime + 0.1);
        },

        setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Ignore if keyboard shortcuts disabled
                if (!this.keyboardEnabled) return;

                // Ignore if typing in input/textarea
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                switch(e.code) {
                    case 'Space':
                        e.preventDefault();
                        if (this.timerRunning && this.focusedItemId) {
                            this.markTimestamp(this.focusedItemId);
                            this.playSound('mark');
                        }
                        break;
                    case 'KeyS':
                        e.preventDefault();
                        if (this.timerRunning) {
                            this.stopRecording();
                        } else if (this.elapsedSeconds === 0) {
                            this.startRecording();
                        } else {
                            this.resumeTimer();
                        }
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        this.focusPreviousItem();
                        this.playSound('nav');
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        this.focusNextItem();
                        this.playSound('nav');
                        break;
                    case 'KeyD':
                        e.preventDefault();
                        if (this.focusedItemId) {
                            this.toggleDiscussed(this.focusedItemId, !this.discussed[this.focusedItemId]);
                        }
                        break;
                    case 'KeyM':
                        e.preventDefault();
                        if (this.timerRunning && this.focusedItemId) {
                            this.markTimestamp(this.focusedItemId);
                            this.playSound('mark');
                            this.focusNextItem();
                        }
                        break;
                    case 'Escape':
                        e.preventDefault();
                        this.focusedItemId = null;
                        break;
                }
            });
        },

        focusFirstUndiscussed() {
            const firstUndiscussed = this.allItemIds.find(id => !this.discussed[id]);
            if (firstUndiscussed) {
                this.focusedItemId = firstUndiscussed;
                this.scrollToFocusedItem();
            }
        },

        focusNextItem() {
            if (!this.focusedItemId) {
                this.focusFirstUndiscussed();
                return;
            }
            const currentIndex = this.allItemIds.indexOf(this.focusedItemId);
            // Find next undiscussed item
            for (let i = currentIndex + 1; i < this.allItemIds.length; i++) {
                if (!this.discussed[this.allItemIds[i]]) {
                    this.focusedItemId = this.allItemIds[i];
                    this.scrollToFocusedItem();
                    return;
                }
            }
            // If no undiscussed found, wrap to first undiscussed
            this.focusFirstUndiscussed();
        },

        focusPreviousItem() {
            if (!this.focusedItemId) {
                this.focusFirstUndiscussed();
                return;
            }
            const currentIndex = this.allItemIds.indexOf(this.focusedItemId);
            // Find previous undiscussed item
            for (let i = currentIndex - 1; i >= 0; i--) {
                if (!this.discussed[this.allItemIds[i]]) {
                    this.focusedItemId = this.allItemIds[i];
                    this.scrollToFocusedItem();
                    return;
                }
            }
            // If no undiscussed found going backward, stay on current or find last undiscussed
            const lastUndiscussed = [...this.allItemIds].reverse().find(id => !this.discussed[id]);
            if (lastUndiscussed) {
                this.focusedItemId = lastUndiscussed;
                this.scrollToFocusedItem();
            }
        },

        scrollToFocusedItem() {
            this.$nextTick(() => {
                const el = document.querySelector(`[data-item-id="${this.focusedItemId}"]`);
                if (el) {
                    el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            });
        },

        formatTime(seconds) {
            const hrs = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            if (hrs > 0) {
                return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        },

        startTimerInterval() {
            this.timerInterval = setInterval(() => {
                this.elapsedSeconds = Math.floor((Date.now() - this.startTime.getTime()) / 1000);
            }, 1000);
        },

        async startRecording() {
            try {
                // Use client time to avoid timezone issues
                const clientStartTime = new Date();

                const response = await fetch(`/podcasts/${this.podcastId}/episodes/${this.guideId}/start`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').content
                    }
                });

                const data = await response.json();
                if (data.success) {
                    this.startTime = clientStartTime;
                    this.timerRunning = true;
                    this.elapsedSeconds = 0;
                    this.startTimerInterval();
                    this.saveState();
                }
            } catch (error) {
                console.error('Failed to start recording:', error);
            }
        },

        resumeTimer() {
            if (this.startTime) {
                this.timerRunning = true;
                this.startTimerInterval();
                this.saveState();
            }
        },

        async stopRecording() {
            if (!confirm('Stop recording? You can view the results after stopping.')) return;

            clearInterval(this.timerInterval);
            this.timerRunning = false;

            try {
                const response = await fetch(`/podcasts/${this.podcastId}/episodes/${this.guideId}/stop`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').content
                    },
                    body: JSON.stringify({ elapsed_seconds: this.elapsedSeconds })
                });

                const data = await response.json();
                if (data.success) {
                    localStorage.removeItem(`guide_${this.guideId}_state`);
                    window.location.href = `/podcasts/${this.podcastId}/episodes/${this.guideId}/`;
                }
            } catch (error) {
                console.error('Failed to stop recording:', error);
            }
        },

        async markTimestamp(itemId) {
            if (!this.timerRunning) return;

            try {
                const response = await fetch(`/podcasts/${this.podcastId}/episodes/${this.guideId}/timestamp/${itemId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').content
                    },
                    body: JSON.stringify({ elapsed_seconds: this.elapsedSeconds })
                });

                const data = await response.json();
                if (data.success) {
                    this.timestamps[itemId] = data.timestamp_seconds;
                    this.discussed[itemId] = true;
                }
            } catch (error) {
                console.error('Failed to capture timestamp:', error);
            }
        },

        async toggleDiscussed(itemId, discussed) {
            this.discussed[itemId] = discussed;

            try {
                await fetch(`/podcasts/${this.podcastId}/episodes/${this.guideId}/items/${itemId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').content
                    },
                    body: JSON.stringify({ discussed })
                });
            } catch (error) {
                console.error('Failed to update discussed status:', error);
            }
        },

        saveState() {
            localStorage.setItem(`guide_${this.guideId}_state`, JSON.stringify({
                startTime: this.startTime?.toISOString(),
                timerRunning: this.timerRunning
            }));
        }
    };
}
</script>
{% endblock %}
