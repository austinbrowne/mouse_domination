{% extends "base.html" %}

{% block title %}LIVE: {{ guide.title }} - {{ podcast.name }} - {{ APP_NAME }}{% endblock %}

{# Alpine-driven item rendering macro - emits x-for compatible template #}
{% macro render_items_alpine(section_key) %}
<div class="divide-y divide-surface-200" x-cloak
     x-sort="(itemId, newPosition) => handleSort(itemId, '{{ section_key }}', newPosition)"
     x-sort:group="episode-guide-items"
     x-sort:config="{ handle: '.sort-handle' }">
    <template x-for="(item, idx) in items['{{ section_key }}'] || []" :key="sortIteration + '-' + item.id">
        <div x-sort:item="item.id"
             :data-item-id="item.id"
             class="py-2 sm:py-1.5 px-3 hover:bg-surface-50 transition-all group"
             :class="{
                'ring-2 ring-primary-500 ring-inset bg-primary-50': focusedItemId === item.id,
                'editing': editingItemId === item.id
             }">
            <!-- View Mode -->
            <div x-show="editingItemId !== item.id"
                 class="flex items-start sm:items-center gap-2 sm:gap-2 cursor-pointer"
                 @click="focusedItemId = item.id">
                <!-- Drag Handle -->
                <div class="sort-handle cursor-grab text-gray-300 hover:text-gray-500 flex-shrink-0 mt-0.5 sm:mt-0" title="Drag to reorder">
                    <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 24 24">
                        <circle cx="9" cy="5" r="1.5"/><circle cx="15" cy="5" r="1.5"/>
                        <circle cx="9" cy="12" r="1.5"/><circle cx="15" cy="12" r="1.5"/>
                        <circle cx="9" cy="19" r="1.5"/><circle cx="15" cy="19" r="1.5"/>
                    </svg>
                </div>
                <!-- Discussed checkbox -->
                <input type="checkbox"
                    :checked="discussed[item.id]"
                    @change="toggleDiscussed(item.id, $event.target.checked)"
                    @click.stop
                    class="w-5 h-5 sm:w-4 sm:h-4 rounded border-gray-300 text-primary-600 focus:ring-primary-500 flex-shrink-0 mt-0.5 sm:mt-0">
                <!-- Topic Number -->
                <span class="text-gray-400 text-xs font-medium flex-shrink-0 mt-0.5 sm:mt-0" x-text="(idx + 1) + '.'"></span>
                <!-- Item content -->
                <div class="flex-1 min-w-0">
                    <div class="font-medium text-gray-900 text-sm" :class="discussed[item.id] ? 'line-through text-gray-400' : ''" x-text="item.title"></div>
                    <template x-for="link in (item.links || [])" :key="link">
                        <a :href="link.startsWith('http') ? link : 'https://' + link" target="_blank" @click.stop class="text-xs text-primary-600 hover:underline truncate block" x-text="link"></a>
                    </template>
                    <template x-if="item.notes">
                        <div class="text-xs text-gray-500" x-text="item.notes"></div>
                    </template>
                </div>
                <!-- Edit/Delete buttons -->
                <div class="flex items-center gap-1 opacity-100 sm:opacity-0 sm:group-hover:opacity-100 flex-shrink-0" @click.stop>
                    <button type="button" @click="startEditingItem(item, '{{ section_key }}')"
                        class="text-gray-400 hover:text-primary-600 p-1" title="Edit">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/></svg>
                    </button>
                    <button type="button" @click="deleteItem('{{ section_key }}', item.id)"
                        class="text-gray-400 hover:text-red-600 p-1" title="Delete">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
                    </button>
                </div>
                <!-- Timestamp display/button -->
                <div class="flex-shrink-0">
                    <template x-if="timestamps[item.id] !== null && timestamps[item.id] !== undefined">
                        <span class="inline-flex items-center px-2 py-1 rounded bg-emerald-100 text-emerald-700 font-mono font-medium text-xs"
                            x-text="formatTime(timestamps[item.id])">
                        </span>
                    </template>
                    <template x-if="timestamps[item.id] === null || timestamps[item.id] === undefined">
                        <button @click.stop="markTimestamp(item.id)"
                            :disabled="!timerRunning"
                            :class="timerRunning ? 'bg-primary-600 hover:bg-primary-700 active:bg-primary-800 text-white' : 'bg-gray-200 text-gray-400 cursor-not-allowed'"
                            class="px-3 py-1.5 sm:py-1 rounded font-medium text-xs transition-colors">
                            MARK
                        </button>
                    </template>
                </div>
            </div>

            <!-- Edit Mode -->
            <div x-show="editingItemId === item.id" class="space-y-3" @click.stop>
                <div>
                    <label class="block text-xs font-medium text-gray-500 mb-1">Title</label>
                    <input type="text" x-model="editingItem.title"
                        class="w-full border border-surface-200 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-primary-500"
                        @keydown.enter.prevent="saveItem('{{ section_key }}')"
                        @keydown.escape.prevent="cancelEditingItem()">
                </div>
                <div>
                    <label class="block text-xs font-medium text-gray-500 mb-1">Links (optional)</label>
                    <div class="space-y-2">
                        <template x-for="(link, linkIdx) in editingItem.links" :key="linkIdx">
                            <div class="flex gap-2">
                                <input type="text" x-model="editingItem.links[linkIdx]"
                                    class="flex-1 border border-surface-200 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-primary-500"
                                    @keydown.escape.prevent="cancelEditingItem()">
                                <button type="button" @click="editingItem.links.splice(linkIdx, 1)" x-show="editingItem.links.length > 1"
                                    class="text-red-500 hover:text-red-700 px-2 text-lg font-bold">-</button>
                            </div>
                        </template>
                        <button type="button" @click="editingItem.links.push('')" class="text-primary-600 hover:text-primary-700 text-sm font-medium">+ Add Link</button>
                    </div>
                </div>
                <div>
                    <label class="block text-xs font-medium text-gray-500 mb-1">Notes (optional)</label>
                    <textarea x-model="editingItem.notes" rows="2"
                        class="w-full border border-surface-200 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-primary-500"
                        @keydown.escape.prevent="cancelEditingItem()"></textarea>
                </div>
                <div class="flex justify-end gap-2">
                    <button type="button" @click="cancelEditingItem()"
                        class="text-gray-500 hover:text-gray-700 text-sm">Cancel</button>
                    <button type="button" @click="saveItem('{{ section_key }}')"
                        class="bg-primary-600 text-white px-4 py-1.5 rounded-lg hover:bg-primary-700 text-sm font-medium">Save</button>
                </div>
            </div>
        </div>
    </template>
    <!-- Empty state -->
    <div x-show="!items['{{ section_key }}'] || items['{{ section_key }}'].length === 0" class="p-4 text-center text-gray-400 text-xs">
        No topics
    </div>
</div>
{% endmacro %}

{# Add item form macro #}
{% macro render_add_form(section_key) %}
<div x-data="{ adding: false, newLinks: [''], newNotes: '' }" class="border-t border-surface-200">
    <div x-show="!adding" class="px-3 py-1.5">
        <button type="button" @click="adding = true" class="text-primary-600 hover:text-primary-700 text-xs font-medium">+ Add</button>
    </div>
    <div x-show="adding" class="p-3 space-y-3 bg-surface-50">
        <div>
            <input type="text" placeholder="Topic title..." x-ref="addTitle"
                class="w-full border border-surface-200 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-primary-500"
                @keydown.enter.prevent="
                    const title = $refs.addTitle.value;
                    if (title.trim()) {
                        addItem('{{ section_key }}', title, newLinks, newNotes);
                        $refs.addTitle.value = '';
                        newLinks = [''];
                        newNotes = '';
                        adding = false;
                    }
                "
                @keydown.escape.prevent="adding = false; newLinks = ['']; newNotes = ''"
                x-effect="if (adding) $nextTick(() => $refs.addTitle?.focus())">
        </div>
        <div>
            <label class="block text-xs font-medium text-gray-500 mb-1">Links (optional)</label>
            <div class="space-y-2">
                <template x-for="(link, linkIdx) in newLinks" :key="linkIdx">
                    <div class="flex gap-2">
                        <input type="text" x-model="newLinks[linkIdx]"
                            class="flex-1 border border-surface-200 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-primary-500">
                        <button type="button" @click="newLinks.splice(linkIdx, 1)" x-show="newLinks.length > 1"
                            class="text-red-500 hover:text-red-700 px-2 text-lg font-bold">-</button>
                    </div>
                </template>
                <button type="button" @click="newLinks.push('')" class="text-primary-600 hover:text-primary-700 text-sm font-medium">+ Add Link</button>
            </div>
        </div>
        <div>
            <label class="block text-xs font-medium text-gray-500 mb-1">Notes (optional)</label>
            <textarea x-model="newNotes" rows="2"
                class="w-full border border-surface-200 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-primary-500"></textarea>
        </div>
        <div class="flex justify-end gap-2">
            <button type="button" @click="adding = false; newLinks = ['']; newNotes = ''"
                class="text-gray-500 hover:text-gray-700 text-sm">Cancel</button>
            <button type="button" @click="
                const title = $refs.addTitle.value;
                if (title.trim()) {
                    addItem('{{ section_key }}', title, newLinks, newNotes);
                    $refs.addTitle.value = '';
                    newLinks = [''];
                    newNotes = '';
                    adding = false;
                }
            " class="bg-primary-600 text-white px-4 py-1.5 rounded-lg hover:bg-primary-700 text-sm font-medium">Add Item</button>
        </div>
    </div>
</div>
{% endmacro %}

{% block content %}
<div class="space-y-4" x-data="episodeGuideLive({{ podcast.id }}, {{ guide.id }}, '{{ guide.status }}', '{{ guide.recording_started_at.isoformat() if guide.recording_started_at else '' }}')">
    <!-- Compact Timer Overlay -->
    <div class="fixed top-16 sm:top-20 left-2 right-2 sm:left-auto sm:right-4 z-40 bg-white rounded-lg shadow-lg border border-surface-200 px-2 sm:px-3 py-2">
        <div class="flex items-center justify-between sm:justify-start gap-2 sm:gap-3">
            <!-- Recording indicator -->
            <template x-if="timerRunning">
                <span class="w-2.5 h-2.5 bg-red-600 rounded-full animate-pulse flex-shrink-0"></span>
            </template>

            <!-- Timer Display -->
            <div class="font-mono font-bold text-base sm:text-lg" :class="timerRunning ? 'text-red-600' : 'text-gray-500'">
                <span x-text="formatTime(elapsedSeconds)">00:00:00</span>
            </div>

            <!-- Timer Controls -->
            <template x-if="!timerRunning && elapsedSeconds === 0">
                <button @click="startRecording()" class="inline-flex items-center gap-1 sm:gap-1.5 bg-emerald-600 text-white px-2.5 sm:px-3 py-1.5 rounded hover:bg-emerald-700 font-medium text-xs sm:text-sm">
                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"/></svg>
                    <span class="hidden xs:inline">Start</span>
                </button>
            </template>

            <template x-if="timerRunning">
                <button @click="stopRecording()" class="inline-flex items-center gap-1 sm:gap-1.5 bg-red-600 text-white px-2.5 sm:px-3 py-1.5 rounded hover:bg-red-700 font-medium text-xs sm:text-sm">
                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 001 1h4a1 1 0 001-1V8a1 1 0 00-1-1H8z" clip-rule="evenodd"/></svg>
                    <span class="hidden xs:inline">Stop</span>
                </button>
            </template>

            <template x-if="!timerRunning && elapsedSeconds > 0">
                <div class="flex gap-1.5 sm:gap-2">
                    <button @click="resumeTimer()" class="inline-flex items-center gap-1 bg-amber-600 text-white px-2 sm:px-2.5 py-1.5 rounded hover:bg-amber-700 font-medium text-xs sm:text-sm">
                        <svg class="w-3.5 h-3.5" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"/></svg>
                        <span class="hidden xs:inline">Resume</span>
                    </button>
                    <a href="{{ url_for('podcasts.view_episode', podcast_id=podcast.id, episode_id=guide.id) }}" class="inline-flex items-center bg-gray-600 text-white px-2 sm:px-2.5 py-1.5 rounded hover:bg-gray-700 font-medium text-xs sm:text-sm">
                        View
                    </a>
                </div>
            </template>

            <!-- Divider - hidden on mobile -->
            <div class="hidden sm:block w-px h-6 bg-gray-200"></div>

            <!-- Settings toggles -->
            <div class="flex items-center gap-1 sm:gap-2">
                <!-- Keyboard toggle - hidden on mobile (no keyboard) -->
                <button @click="toggleKeyboard()"
                        :class="keyboardEnabled ? 'text-primary-600 bg-primary-50' : 'text-gray-400 hover:text-gray-600'"
                        class="hidden sm:block p-1.5 rounded transition-colors"
                        :title="keyboardEnabled ? 'Keyboard shortcuts ON' : 'Keyboard shortcuts OFF'">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19V5M5 12l7-7 7 7"/>
                    </svg>
                </button>
                <!-- Sound toggle -->
                <button @click="toggleSound()"
                        :class="soundEnabled ? 'text-primary-600 bg-primary-50' : 'text-gray-400 hover:text-gray-600'"
                        class="p-1.5 rounded transition-colors"
                        :title="soundEnabled ? 'Sound ON' : 'Sound OFF'">
                    <svg x-show="soundEnabled" class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072M18.364 5.636a9 9 0 010 12.728M6 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h2l4-4v14l-4-4z"/>
                    </svg>
                    <svg x-show="!soundEnabled" class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z"/>
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2"/>
                    </svg>
                </button>
                <!-- Help tooltip - hidden on mobile -->
                <div class="hidden sm:block relative" x-data="{ showHelp: false }">
                    <button @mouseenter="showHelp = true" @mouseleave="showHelp = false"
                            class="p-1.5 text-gray-400 hover:text-gray-600 rounded transition-colors">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                        </svg>
                    </button>
                    <div x-show="showHelp" x-cloak
                         class="absolute right-0 top-full mt-2 w-48 bg-gray-900 text-white text-xs rounded-lg shadow-lg p-3 z-50">
                        <div class="font-semibold mb-2">Keyboard Shortcuts</div>
                        <div class="space-y-1">
                            <div class="flex justify-between"><span>Space</span><span class="text-gray-400">Mark timestamp</span></div>
                            <div class="flex justify-between"><span>&uarr; / &darr;</span><span class="text-gray-400">Navigate</span></div>
                            <div class="flex justify-between"><span>D</span><span class="text-gray-400">Toggle discussed</span></div>
                            <div class="flex justify-between"><span>M</span><span class="text-gray-400">Mark + next</span></div>
                            <div class="flex justify-between"><span>S</span><span class="text-gray-400">Start/Stop</span></div>
                            <div class="flex justify-between"><span>Esc</span><span class="text-gray-400">Clear focus</span></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Spacer for fixed timer overlay on mobile -->
    <div class="h-12 sm:h-0"></div>

    <!-- Page Header -->
    <div class="flex items-center justify-between gap-2">
        <div class="flex items-center gap-2 min-w-0">
            <a href="{{ url_for('podcasts.edit_episode', podcast_id=podcast.id, episode_id=guide.id) }}" class="text-gray-400 hover:text-gray-600 flex-shrink-0">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"/></svg>
            </a>
            {% if guide.episode_number %}
                <span class="text-gray-400 text-xs sm:text-sm flex-shrink-0">#{{ guide.episode_number }}</span>
            {% endif %}
            <h1 class="text-base sm:text-lg font-bold text-gray-900 truncate">{{ guide.title }}</h1>
        </div>
        <span class="text-xs text-gray-500 flex-shrink-0 hidden sm:block" x-show="Object.values(timestamps).filter(t => t !== null).length > 0">
            <span x-text="Object.values(timestamps).filter(t => t !== null).length"></span> timestamps
        </span>
    </div>

    <!-- Sections -->
    <div class="space-y-4">
        <!-- INTRO Section -->
        <div>
            <div class="bg-gradient-to-r from-purple-600 to-purple-700 rounded-t-xl px-4 py-2">
                <h2 class="text-base font-bold text-white uppercase tracking-wide">INTRO</h2>
            </div>
            <div class="bg-white rounded-b-xl border border-t-0 border-surface-200 overflow-hidden">
                {% set intro_content = guide.get_intro_content() %}
                {% if intro_content or guide.previous_poll or guide.new_poll %}
                <div class="bg-blue-50 border-b border-blue-100 p-3">
                    <ul class="text-xs text-blue-800 space-y-0.5">
                        {% for line in intro_content %}
                        <li>{{ line }}</li>
                        {% endfor %}
                        {% if guide.previous_poll or guide.new_poll %}
                        <li class="font-semibold">
                            Previous Poll: {{ guide.previous_poll or '[Not set]' }}
                            {% if guide.previous_poll_link %}
                            <a href="{{ guide.previous_poll_link if guide.previous_poll_link.startswith('http') else 'https://' + guide.previous_poll_link }}" target="_blank" class="text-blue-600 hover:underline ml-1">[Link]</a>
                            {% endif %}
                        </li>
                        <li class="font-semibold">
                            New Poll: {{ guide.new_poll or '[Not set]' }}
                            {% if guide.new_poll_link %}
                            <a href="{{ guide.new_poll_link if guide.new_poll_link.startswith('http') else 'https://' + guide.new_poll_link }}" target="_blank" class="text-blue-600 hover:underline ml-1">[Link]</a>
                            {% endif %}
                        </li>
                        {% endif %}
                    </ul>
                </div>
                {% endif %}
                {{ render_items_alpine('introduction') }}
                {{ render_add_form('introduction') }}
            </div>
        </div>

        <!-- NEWS Section -->
        <div>
            <div class="bg-gradient-to-r from-red-600 to-red-700 rounded-t-xl px-4 py-2">
                <h2 class="text-base font-bold text-white uppercase tracking-wide">NEWS</h2>
            </div>
            <div class="bg-white rounded-b-xl border border-t-0 border-surface-200 overflow-hidden">
                {% for sub_key, sub_name in [('news_mice', 'Mice'), ('news_other', 'Other'), ('news_pads', 'Pads'), ('news_keyboards', 'Keyboards')] %}
                    <div class="py-1.5 px-3 bg-surface-50 border-b border-surface-200 flex items-center justify-between">
                        <div>
                            <span class="text-xs font-semibold text-gray-700">{{ sub_name }}</span>
                            <span class="text-xs text-gray-500 ml-1" x-text="'(' + (items['{{ sub_key }}'] || []).length + ')'"></span>
                        </div>
                    </div>
                    {{ render_items_alpine(sub_key) }}
                    {{ render_add_form(sub_key) }}
                {% endfor %}
            </div>
        </div>

        <!-- COMMUNITY RECAP Section -->
        <div>
            <div class="bg-gradient-to-r from-emerald-600 to-emerald-700 rounded-t-xl px-4 py-2">
                <h2 class="text-base font-bold text-white uppercase tracking-wide">COMMUNITY RECAP</h2>
            </div>
            <div class="bg-white rounded-b-xl border border-t-0 border-surface-200 overflow-hidden">
                {{ render_items_alpine('community_recap') }}
                {{ render_add_form('community_recap') }}
            </div>
        </div>

        <!-- PERSONAL RAMBLINGS Section -->
        <div>
            <div class="bg-gradient-to-r from-amber-600 to-amber-700 rounded-t-xl px-4 py-2">
                <h2 class="text-base font-bold text-white uppercase tracking-wide">PERSONAL RAMBLINGS</h2>
            </div>
            <div class="bg-white rounded-b-xl border border-t-0 border-surface-200 overflow-hidden">
                {{ render_items_alpine('personal_ramblings') }}
                {{ render_add_form('personal_ramblings') }}
            </div>
        </div>

        <!-- OUTRO Section -->
        <div>
            <div class="bg-gradient-to-r from-gray-600 to-gray-700 rounded-t-xl px-4 py-2">
                <h2 class="text-base font-bold text-white uppercase tracking-wide">OUTRO</h2>
            </div>
            <div class="bg-white rounded-b-xl border border-t-0 border-surface-200 overflow-hidden">
                {% set outro_content = guide.get_outro_content() %}
                {% if outro_content %}
                <div class="bg-blue-50 border-b border-blue-100 p-3">
                    <ul class="text-xs text-blue-800 space-y-0.5">
                        {% for line in outro_content %}
                        <li>{{ line }}</li>
                        {% endfor %}
                    </ul>
                </div>
                {% endif %}
                {{ render_items_alpine('outro') }}
                {{ render_add_form('outro') }}
            </div>
        </div>

        <!-- Custom Sections -->
        {% if guide.custom_sections %}
            {% for custom_section in guide.custom_sections %}
            <div>
                <div class="bg-gradient-to-r from-indigo-600 to-indigo-700 rounded-t-xl px-4 py-2">
                    <h2 class="text-base font-bold text-white uppercase tracking-wide">{{ custom_section.name }}</h2>
                </div>
                <div class="bg-white rounded-b-xl border border-t-0 border-surface-200 overflow-hidden">
                    {{ render_items_alpine(custom_section.key) }}
                    {{ render_add_form(custom_section.key) }}
                </div>
            </div>
            {% endfor %}
        {% endif %}
    </div>
</div>
{% endblock %}

{% block scripts %}
<!-- SortableJS for drag-and-drop -->
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>

<style>
/* Drag-and-drop styles */
.sortable-ghost {
    opacity: 0.4;
    background-color: #dbeafe !important;
}
.sortable-chosen {
    background-color: #eff6ff !important;
}
.sortable-drag {
    opacity: 1;
    box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
}
.sort-handle {
    cursor: grab;
}
.sort-handle:active {
    cursor: grabbing;
}
</style>

<script>
function episodeGuideLive(podcastId, guideId, initialStatus, startedAtISO) {
    // Parse items_json into grouped structure
    const itemsFlat = {{ items_json | tojson | safe }};
    const groupedItems = itemsFlat.reduce((acc, item) => {
        if (!acc[item.section]) acc[item.section] = [];
        acc[item.section].push(item);
        return acc;
    }, {});
    Object.keys(groupedItems).forEach(section => {
        groupedItems[section].sort((a, b) => a.position - b.position);
    });

    return {
        podcastId: podcastId,
        guideId: guideId,
        timerRunning: initialStatus === 'recording',
        elapsedSeconds: 0,
        timerInterval: null,
        startTime: startedAtISO ? new Date(startedAtISO) : null,

        // Keyboard shortcuts
        focusedItemId: null,
        keyboardEnabled: false,
        soundEnabled: false,

        // Items state (Alpine-driven)
        items: groupedItems,
        customSections: {{ custom_sections_json | tojson | safe }},
        sortIteration: 0,

        // CRUD state
        editingItemId: null,
        editingItem: { title: '', links: [''], notes: '' },
        editingSectionKey: null,

        // Item state maps (initialized from items_json)
        timestamps: Object.fromEntries(itemsFlat.map(i => [i.id, i.timestamp_seconds !== undefined ? i.timestamp_seconds : null])),
        discussed: Object.fromEntries(itemsFlat.map(i => [i.id, i.discussed || false])),

        get allItemIds() {
            const order = ['introduction', 'news_mice', 'news_other', 'news_pads', 'news_keyboards',
                           'community_recap', 'personal_ramblings', 'outro',
                           ...this.customSections.map(s => s.key)];
            return order.flatMap(key => (this.items[key] || []).map(i => i.id));
        },

        init() {
            // If status is draft, clear any stale localStorage and start fresh
            if ('{{ guide.status }}' === 'draft') {
                localStorage.removeItem(`guide_${this.guideId}_state`);
                this.startTime = null;
                this.timerRunning = false;
                this.elapsedSeconds = 0;
            }

            // Resume timer if already recording (use client-side tracking)
            if (this.timerRunning && this.startTime) {
                this.elapsedSeconds = Math.max(0, Math.floor((Date.now() - this.startTime.getTime()) / 1000));
                this.startTimerInterval();
            }

            // Try to restore from localStorage (only if not already set from server)
            const saved = localStorage.getItem(`guide_${this.guideId}_state`);
            if (saved && !this.startTime) {
                const state = JSON.parse(saved);
                if (state.startTime) {
                    this.startTime = new Date(state.startTime);
                    this.elapsedSeconds = Math.max(0, Math.floor((Date.now() - this.startTime.getTime()) / 1000));
                    if (state.timerRunning) {
                        this.timerRunning = true;
                        this.startTimerInterval();
                    }
                }
            }

            // Load keyboard/sound preferences from localStorage
            const prefs = localStorage.getItem(`guide_live_prefs`);
            if (prefs) {
                const p = JSON.parse(prefs);
                this.keyboardEnabled = p.keyboardEnabled ?? false;
                this.soundEnabled = p.soundEnabled ?? false;
            }

            // Set up keyboard shortcuts
            this.setupKeyboardShortcuts();

            // Auto-focus first undiscussed item if keyboard enabled
            if (this.keyboardEnabled) {
                this.focusFirstUndiscussed();
            }
        },

        toggleKeyboard() {
            this.keyboardEnabled = !this.keyboardEnabled;
            this.savePrefs();
            if (this.keyboardEnabled && !this.focusedItemId) {
                this.focusFirstUndiscussed();
            } else if (!this.keyboardEnabled) {
                this.focusedItemId = null;
            }
        },

        toggleSound() {
            this.soundEnabled = !this.soundEnabled;
            this.savePrefs();
        },

        savePrefs() {
            localStorage.setItem(`guide_live_prefs`, JSON.stringify({
                keyboardEnabled: this.keyboardEnabled,
                soundEnabled: this.soundEnabled
            }));
        },

        playSound(type) {
            if (!this.soundEnabled) return;
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain);
            gain.connect(ctx.destination);
            gain.gain.value = 0.1;
            if (type === 'mark') {
                osc.frequency.value = 880;
            } else {
                osc.frequency.value = 440;
            }
            osc.start();
            osc.stop(ctx.currentTime + 0.1);
        },

        setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Ignore if keyboard shortcuts disabled
                if (!this.keyboardEnabled) return;

                // Ignore if typing in input/textarea
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                // Ignore if editing an item (suppress all shortcuts)
                if (this.editingItemId !== null) return;

                switch(e.code) {
                    case 'Space':
                        e.preventDefault();
                        if (this.timerRunning && this.focusedItemId) {
                            this.markTimestamp(this.focusedItemId);
                            this.playSound('mark');
                        }
                        break;
                    case 'KeyS':
                        e.preventDefault();
                        if (this.timerRunning) {
                            this.stopRecording();
                        } else if (this.elapsedSeconds === 0) {
                            this.startRecording();
                        } else {
                            this.resumeTimer();
                        }
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        this.focusPreviousItem();
                        this.playSound('nav');
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        this.focusNextItem();
                        this.playSound('nav');
                        break;
                    case 'KeyD':
                        e.preventDefault();
                        if (this.focusedItemId) {
                            this.toggleDiscussed(this.focusedItemId, !this.discussed[this.focusedItemId]);
                        }
                        break;
                    case 'KeyM':
                        e.preventDefault();
                        if (this.timerRunning && this.focusedItemId) {
                            this.markTimestamp(this.focusedItemId);
                            this.playSound('mark');
                            this.focusNextItem();
                        }
                        break;
                    case 'Escape':
                        e.preventDefault();
                        this.focusedItemId = null;
                        break;
                }
            });
        },

        focusFirstUndiscussed() {
            const firstUndiscussed = this.allItemIds.find(id => !this.discussed[id]);
            if (firstUndiscussed) {
                this.focusedItemId = firstUndiscussed;
                this.scrollToFocusedItem();
            }
        },

        focusNextItem() {
            if (!this.focusedItemId) {
                this.focusFirstUndiscussed();
                return;
            }
            const currentIndex = this.allItemIds.indexOf(this.focusedItemId);
            for (let i = currentIndex + 1; i < this.allItemIds.length; i++) {
                if (!this.discussed[this.allItemIds[i]]) {
                    this.focusedItemId = this.allItemIds[i];
                    this.scrollToFocusedItem();
                    return;
                }
            }
            this.focusFirstUndiscussed();
        },

        focusPreviousItem() {
            if (!this.focusedItemId) {
                this.focusFirstUndiscussed();
                return;
            }
            const currentIndex = this.allItemIds.indexOf(this.focusedItemId);
            for (let i = currentIndex - 1; i >= 0; i--) {
                if (!this.discussed[this.allItemIds[i]]) {
                    this.focusedItemId = this.allItemIds[i];
                    this.scrollToFocusedItem();
                    return;
                }
            }
            const lastUndiscussed = [...this.allItemIds].reverse().find(id => !this.discussed[id]);
            if (lastUndiscussed) {
                this.focusedItemId = lastUndiscussed;
                this.scrollToFocusedItem();
            }
        },

        scrollToFocusedItem() {
            this.$nextTick(() => {
                const el = document.querySelector(`[data-item-id="${this.focusedItemId}"]`);
                if (el) {
                    el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            });
        },

        formatTime(seconds) {
            const hrs = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            if (hrs > 0) {
                return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        },

        startTimerInterval() {
            this.timerInterval = setInterval(() => {
                this.elapsedSeconds = Math.floor((Date.now() - this.startTime.getTime()) / 1000);
            }, 1000);
        },

        async startRecording() {
            try {
                const clientStartTime = new Date();
                const response = await fetch(`/podcasts/${this.podcastId}/episodes/${this.guideId}/start`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').content
                    }
                });
                const data = await response.json();
                if (data.success) {
                    this.startTime = clientStartTime;
                    this.timerRunning = true;
                    this.elapsedSeconds = 0;
                    this.startTimerInterval();
                    this.saveState();
                }
            } catch (error) {
                console.error('Failed to start recording:', error);
            }
        },

        resumeTimer() {
            if (this.startTime) {
                this.timerRunning = true;
                this.startTimerInterval();
                this.saveState();
            }
        },

        async stopRecording() {
            if (!confirm('Stop recording? You can view the results after stopping.')) return;

            clearInterval(this.timerInterval);
            this.timerRunning = false;

            try {
                const response = await fetch(`/podcasts/${this.podcastId}/episodes/${this.guideId}/stop`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').content
                    },
                    body: JSON.stringify({ elapsed_seconds: this.elapsedSeconds })
                });
                const data = await response.json();
                if (data.success) {
                    localStorage.removeItem(`guide_${this.guideId}_state`);
                    window.location.href = `/podcasts/${this.podcastId}/episodes/${this.guideId}/`;
                }
            } catch (error) {
                console.error('Failed to stop recording:', error);
            }
        },

        async markTimestamp(itemId) {
            if (!this.timerRunning) return;

            try {
                const response = await fetch(`/podcasts/${this.podcastId}/episodes/${this.guideId}/timestamp/${itemId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').content
                    },
                    body: JSON.stringify({ elapsed_seconds: this.elapsedSeconds })
                });
                const data = await response.json();
                if (data.success) {
                    this.timestamps[itemId] = data.timestamp_seconds;
                    this.discussed[itemId] = true;
                }
            } catch (error) {
                console.error('Failed to capture timestamp:', error);
            }
        },

        async toggleDiscussed(itemId, discussed) {
            this.discussed[itemId] = discussed;

            try {
                await fetch(`/podcasts/${this.podcastId}/episodes/${this.guideId}/items/${itemId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').content
                    },
                    body: JSON.stringify({ discussed })
                });
            } catch (error) {
                console.error('Failed to update discussed status:', error);
            }
        },

        // CRUD Methods

        startEditingItem(item, sectionKey) {
            this.editingItemId = item.id;
            this.editingSectionKey = sectionKey;
            this.editingItem = {
                title: item.title,
                links: item.links && item.links.length ? [...item.links] : [''],
                notes: item.notes || ''
            };
        },

        cancelEditingItem() {
            this.editingItemId = null;
            this.editingSectionKey = null;
            this.editingItem = { title: '', links: [''], notes: '' };
        },

        async saveItem(section) {
            if (!this.editingItem.title.trim()) return;

            const cleanLinks = this.editingItem.links
                .filter(l => l && l.trim())
                .map(l => l.trim());

            try {
                const response = await fetch(`/podcasts/${this.podcastId}/episodes/${this.guideId}/items/${this.editingItemId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').content
                    },
                    body: JSON.stringify({
                        title: this.editingItem.title.trim(),
                        links: cleanLinks.length ? cleanLinks : null,
                        notes: this.editingItem.notes.trim() || null
                    })
                });

                const data = await response.json();
                if (data.success) {
                    const itemIndex = this.items[section].findIndex(i => i.id === this.editingItemId);
                    if (itemIndex !== -1) {
                        this.items[section][itemIndex] = data.item;
                    }
                    this.cancelEditingItem();
                } else {
                    console.error('Failed to save item:', data.error);
                }
            } catch (error) {
                console.error('Failed to save item:', error);
            }
        },

        async addItem(section, title, links, notes) {
            if (!title || !title.trim()) return;

            const cleanLinks = (links || [])
                .filter(l => l && l.trim())
                .map(l => l.trim());

            try {
                const response = await fetch(`/podcasts/${this.podcastId}/episodes/${this.guideId}/items`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').content
                    },
                    body: JSON.stringify({
                        section,
                        title: title.trim(),
                        links: cleanLinks.length ? cleanLinks : null,
                        notes: (notes && notes.trim()) || null
                    })
                });

                const data = await response.json();
                if (data.success) {
                    if (!this.items[section]) this.items[section] = [];
                    this.items[section].push(data.item);
                    // Initialize state for the new item
                    this.discussed[data.item.id] = false;
                    this.timestamps[data.item.id] = null;
                } else {
                    console.error('Failed to add item:', data.error);
                }
            } catch (error) {
                console.error('Failed to add item:', error);
            }
        },

        async deleteItem(section, itemId) {
            if (!confirm('Delete this item?')) return;

            try {
                const response = await fetch(`/podcasts/${this.podcastId}/episodes/${this.guideId}/items/${itemId}`, {
                    method: 'DELETE',
                    headers: {
                        'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').content
                    }
                });

                const data = await response.json();
                if (data.success) {
                    this.items[section] = this.items[section].filter(i => i.id !== itemId);
                    delete this.discussed[itemId];
                    delete this.timestamps[itemId];
                    // Clear focus if deleting focused item
                    if (this.focusedItemId === itemId) {
                        this.focusedItemId = null;
                    }
                }
            } catch (error) {
                console.error('Failed to delete item:', error);
            }
        },

        // Drag-drop sort handler
        async handleSort(itemId, toSection, newPosition) {
            let fromSection = null;
            let item = null;
            for (const [section, sectionItems] of Object.entries(this.items)) {
                if (!sectionItems) continue;
                const found = sectionItems.find(i => i.id === itemId);
                if (found) {
                    fromSection = section;
                    item = found;
                    break;
                }
            }

            if (!item || !fromSection) {
                console.error('Item not found:', itemId);
                return;
            }

            // Save state for revert on error
            const prevFromItems = [...this.items[fromSection]];
            const prevToItems = toSection !== fromSection && this.items[toSection] ? [...this.items[toSection]] : null;

            try {
                const response = await fetch(`/podcasts/${this.podcastId}/episodes/${this.guideId}/items/move`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').content
                    },
                    body: JSON.stringify({
                        item_id: itemId,
                        target_section: toSection,
                        new_position: newPosition
                    })
                });

                if (!response.ok) {
                    throw new Error('Server error: ' + response.status);
                }

                const data = await response.json();
                if (!data.success) {
                    throw new Error(data.error || 'Unknown error');
                }

                // Update local arrays
                if (fromSection === toSection) {
                    const oldIndex = this.items[fromSection].findIndex(i => i.id === itemId);
                    if (oldIndex !== -1) {
                        this.items[fromSection].splice(oldIndex, 1);
                        this.items[fromSection].splice(newPosition, 0, data.item);
                    }
                } else {
                    const oldIndex = this.items[fromSection].findIndex(i => i.id === itemId);
                    if (oldIndex !== -1) {
                        this.items[fromSection].splice(oldIndex, 1);
                    }
                    if (!this.items[toSection]) {
                        this.items[toSection] = [];
                    }
                    this.items[toSection].splice(newPosition, 0, data.item);
                }

                this.sortIteration++;

            } catch (error) {
                console.error('Move failed:', error);
                // Revert local state instead of reloading
                this.items[fromSection] = prevFromItems;
                if (prevToItems !== null) {
                    this.items[toSection] = prevToItems;
                }
                this.sortIteration++;
            }
        },

        saveState() {
            localStorage.setItem(`guide_${this.guideId}_state`, JSON.stringify({
                startTime: this.startTime?.toISOString(),
                timerRunning: this.timerRunning
            }));
        }
    };
}
</script>
{% endblock %}
